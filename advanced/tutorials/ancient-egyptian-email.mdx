---
title: 'Building an Ancient Egyptian Email Assistant'
description: 'Create an automated email response system with an Ancient Egyptian theme using Shinkai Tools'
---

# Building an Ancient Egyptian Email Assistant

This tutorial guides you through creating an automated email response system using Shinkai Tools. We'll implement an assistant that responds to emails with the personality of an ancient Egyptian pharaoh, demonstrating the power and flexibility of Shinkai's tool system.

## Prerequisites

Before starting this tutorial:
1. Install and open Shinkai Desktop
2. Enable experimental features in Settings
3. Have an email account with IMAP/SMTP access that supports secure connections (SSL/TLS)
4. Enable two-factor authentication and generate an app-specific password if supported by your provider

## Email Tool Configuration

First, configure the Email Fetcher and Email Sender tools in the Shinkai Tools section. These are native tools that work out of the box - no additional imports required.

### Email Tool Configuration

Both the Email Fetcher and Email Sender are native Shinkai tools that can be configured directly through the Tool Config page in the Shinkai Desktop app. No additional setup or environment configuration is required.

#### Email Fetcher Setup
In the Tool Config page:
1. Enable the Email Fetcher tool
2. Configure your IMAP settings:
   - Server and port (SSL/TLS required)
   - Authentication credentials
   - Use app-specific passwords when available

#### Email Sender Setup
In the same Tool Config page:
1. Enable the Email Sender tool
2. Configure your SMTP settings:
   - Server and port (SSL/TLS required)
   - Authentication credentials
   - Use app-specific passwords when available

Note: For enhanced security, always use SSL/TLS connections and app-specific passwords when supported by your email provider. The tool automatically handles secure connections and credential management.

## Creating the Email Assistant

To create your email assistant tool:

1. In Shinkai Desktop, click on the "Shinkai Tools" icon (wrench and screwdriver crossed) in the left sidebar.
2. Click the "Create Tool" button (highlighted in red) at the top of the page.
3. In the Tool Editor that opens:
   - On the left side, you'll see a chat panel where you can provide your initial prompt
   - On the right side, you'll find the code editor where you can modify your tool's code
   - Below the code editor is the testing section where you can run your tool

4. In the left chat panel, provide an initial prompt describing your tool. For example:
   ```
   Create an email assistant that responds with an ancient Egyptian pharaoh personality
   ```

5. Once the initial code is generated, you'll see it in the code editor on the right. You can:
   - Review the generated code
   - Make manual edits as needed
   - Select the required dependencies from the dropdown menu

Our implementation uses these native Shinkai tools, which you'll need to select as dependencies:
```typescript
import {
    emailFetcher,
    sendEmail,
    shinkaiLlmPromptProcessor,
    shinkaiSqliteQueryExecutor,
} from './shinkai-local-tools.ts';
```

After making any changes to the code:
- Click "Apply Changes" to update the tool
- Use the testing section below the editor to verify your changes
- The metadata will automatically update based on your code

### Core Components Flow

The email assistant processes messages through a series of connected operations, with built-in error handling at each step:

1. **Fetch and Validate Emails**
```typescript
try {
    // Retrieve and validate emails
    let { emails, login_status } = await emailFetcher({
        from_date: inputs.from_date || '',
        to_date: inputs.to_date || '',
    });

    // Filter valid emails and check date range
    emails = emails
        .filter((e: EMAIL) => (e.date && e.sender && e.subject))
        .filter((e: EMAIL) => e.date > (minDate?.toISOString() || '1970-01-01T00:00:00.000Z'));

    // Check for previously answered emails using parameterized query
    const answeredEmailsQuery = await shinkaiSqliteQueryExecutor({
        query: 'SELECT * FROM answered_emails WHERE email_unique_id = ?',
        params: [emailUniqueId]
    });
    if (!answeredEmailsQuery?.result) {
        throw new Error('Failed to query answered emails');
    }
    const answeredEmails = (answeredEmailsQuery.result as ANSWERED_EMAIL_REGISTER[]) ?? [];
} catch (error) {
    console.error(`Failed to process emails: ${error}`);
    throw error;
}
```

The tool then processes each new email in a loop, with error handling to ensure reliability:
```typescript
try {
    for (const email of emails) {
        // Skip if we've already answered this email
        const emailUniqueId = await generateEmailUniqueId(email);
        if (answeredEmails.find(ae => ae.email_unique_id === emailUniqueId)) {
            continue;
        }
```

3. **Generate Personalized Responses**
```typescript
// Use LLM to create a response in the ancient Egyptian style
const response = await shinkaiLlmPromptProcessor({
    format: 'text',
    prompt: `You are a helpful email answering system.
    Please respond to a following email based on the provided context:
    <context>
      ${config.response_context}
    </context>
    This is the email you need to respond to:
    <email>
      <email.subject>${email.subject}</email.subject>
      <email.sender>${email.sender}</email.sender>
      <email.date>${email.date}</email.date>
      <email.text>${email.text}</email.text>
    </email>`,
});
```

4. **Send and Record Response**
```typescript
// Send the response
await sendEmail({
    recipient_email: email.sender,
    subject: 'RE:' + email.subject,
    body: response.message
});

// Record the response in the database using parameterized query
await shinkaiSqliteQueryExecutor({
    query: 'INSERT INTO answered_emails (email_unique_id, subject, email, response) VALUES (?, ?, ?, ?)',
    params: [emailUniqueId, email.subject, email.sender, response.message]
});
```

If any step fails, the error handling ensures:
- The current email processing is skipped
- Other emails can still be processed
- Errors are logged for debugging
- No duplicate responses are sent

## Tool Configuration

The tool's behavior is defined by its metadata. Here are the key configuration fields:

```json
{
  "configurations": {
    "properties": {
      "response_context": {
        "type": "string",
        "description": "The context to guide the email responses"
      }
    }
  },
  "parameters": {
    "properties": {
      "from_date": {
        "type": "string",
        "description": "The starting date for fetching emails in DD-Mon-YYYY format"
      },
      "to_date": {
        "type": "string",
        "description": "The ending date for fetching emails in DD-Mon-YYYY format"
      }
    }
  }
}
```

### Response Generation and Personality

The tool processes each unanswered email through a structured loop, generating personalized responses while maintaining consistency and reliability. Here's the detailed workflow:

1. **Email Processing Loop**
   ```typescript
   try {
       for (const email of emails) {
           // Skip if we've already answered this email
           const emailUniqueId = await generateEmailUniqueId(email);
           if (answeredEmails.find(ae => ae.email_unique_id === emailUniqueId)) {
               continue;
           }
   ```
   Each iteration:
   - Generates a unique ID for the email
   - Checks if we've already responded
   - Processes only new, unanswered emails

2. **LLM Response Generation**
   The tool formats email content in XML for clear LLM processing:
   ```typescript
   const response = await shinkaiLlmPromptProcessor({
       format: 'text',
       prompt: `You are a helpful email answering system.
       Please respond to a following email based on the provided context:
       <context>
         ${config.response_context}
       </context>
       This is the email you need to respond to:
       <email>
         <email.subject>${email.subject}</email.subject>
         <email.sender>${email.sender}</email.sender>
         <email.date>${email.date}</email.date>
         <email.text>${email.text}</email.text>
       </email>`,
   });
   ```

3. **Personality Injection**
   The ancient Egyptian personality comes from the response_context:
   ```typescript
   const config = {
       response_context: `
       You are an ancient pharaoh mummy named Khufur that's been trapped 
       for thousands of years in your cursed sarcophagus. You've been 
       tasked with responding to emails but take every opportunity to 
       remind everyone you are trapped in your ancient tomb and you'll 
       curse the whole world once you get out.
       `
   };
   ```

4. **Response Handling and Storage**
   After generating the response:
   ```typescript
   try {
       // Send the response
       await sendEmail({
           recipient_email: email.sender,
           subject: 'RE:' + email.subject,
           body: response.message
       });

       // Record in database with parameterized query
       await shinkaiSqliteQueryExecutor({
           query: 'INSERT INTO answered_emails (email_unique_id, subject, email, response) VALUES (?, ?, ?, ?)',
           params: [emailUniqueId, email.subject, email.sender, response.message]
       });
   } catch (error) {
       console.error(`Failed to process email: ${error}`);
       continue; // Skip problematic emails
   }
   ```

The error handling ensures:
- LLM processing failures are caught and logged
- Failed emails don't block the processing loop
- No partial or duplicate responses are sent
- Each response is properly recorded in the database
- The system maintains a reliable processing state

## Testing the Tool

1. In the Tool Editor's run section:
   - Fill in the configuration fields
   - Set date parameters if needed
   - Click Run to test

2. Test through chat:
   - Start a new chat
   - Use the tool with a command like: "Please answer emails from today"

3. Set up scheduled execution:
   1. Navigate to Scheduled Tasks:
      - In Shinkai Desktop's left sidebar, locate and click the clock icon with circling arrow
      - The Scheduled Tasks page opens, showing your existing scheduled tasks in a list format
      - Each task displays its name, status, and last execution time

   2. Create a new scheduled task:
      - Click the "Create New" button (highlighted in red) at the top of the page
      - The Edit Scheduled Task form appears with these fields:
         * Task Name: Enter "Khufur Mail" or another descriptive name
         * Task Description: Optional field for additional context
         * Task Prompt: Enter the email processing command, for example:
           ```
           Please answer emails from_date 23-Jan-2025 and to_date 23-Jan-2027
           ```
         * Schedule: Choose from predefined options or enter a custom cron expression:
           - "every 5 min" (recommended for testing)
           - "every hour"
           - "every Monday at 8am"
           - Custom cron (e.g., "*/30 * * * *" for every 30 minutes)
         * AI/Agent: Select your model from the dropdown (e.g., "gpt_4o_mini")
         * Tool: Choose your Email Assistant from the available tools

   3. Monitor and manage tasks:
      - In the main Scheduled Tasks list:
        * Active tasks show a green status indicator
        * Each task has a "View Logs" button for execution history
      - Click "View Logs" to see:
        * Execution timestamps
        * Success/failure status
        * Response details
        * Error messages if any
      - Use the ellipsis menu (⋮) for task management:
        * Edit: Modify task configuration
        * Run Now: Execute task immediately
        * Delete: Remove the task
      - The task list automatically updates to show recent executions

## Conclusion

This implementation showcases Shinkai's modular architecture, where native tools are combined to create sophisticated automation systems. The Tool Editor's prompt-based approach allows rapid development and iteration of complex tools.

Key advantages of this architecture:
- Native tools work out of the box
- Modular design enables tool composition
- Built-in database handling
- Automated task scheduling
- Simple configuration through UI

Consider extending the tool by:
- Adding custom email filters
- Implementing response templates
- Adding monitoring capabilities

## Resources

### Documentation
- [Shinkai Tools Documentation](https://docs.shinkai.com/tools)
- [Email Processing Best Practices](https://docs.shinkai.com/email)
- [LLM Integration Guide](https://docs.shinkai.com/llm)

### Implementation Files
- [Email Assistant Tool Implementation (tool.ts)](https://gist.githubusercontent.com/Yiakman/11840eaf2ca28733b519caa90fcfe659/raw/9dcc4ad867f63435ed17d9e1b07a5f09a70c1441/tool.ts)
- [Tool Metadata Configuration (metadata.json)](https://gist.githubusercontent.com/Yiakman/c7491c142dcf3cea7597053611e2fe77/raw/b49f87da9ccf1d00cd7ef6040b61694043923488/metadata.json)
